# Building a Secure and Decentralized Messaging App with Actor-Based Communication on the Blockchain

# distributed messenger with central Main contract creator

Benefits of distributed Messaging Dapp  __:__

Enhanced Security: Actor\-based communication minimizes attack vectors\, reducing potential vulnerabilities

Scalability: Actor\-based architecture enables efficient parallel processing of transactions\, improving performance

Privacy: Messages are end\-to\-end encrypted\, ensuring confidentiality and protecting user data

Decentralization: The absence of a central authority empowers users and promotes censorship resistance

User Control: Users have ownership of their data and cryptographic identities\, promoting data sovereignty

![](img/Building%20a%20Secure%20and%20Decentralized%20Messaging%20App0.png)

# Main connector

![](img/Building%20a%20Secure%20and%20Decentralized%20Messaging%20App1.png)

* Functionality:
* Register user public key:
  * User just sends his public key
* Create new group chat:
  * User send generated by him encrypted symmetric key for future created chat
* Create new pair chat:
  * User send symmetric key encrypted by his public key and by public key of user with which he wants to start communication and address of that user
* Add user in the chat:
  * Can only be sent by chats themselves \(so\, if user want to add another user in the chat he must send it to the chat\, and chat in its turn send it to MAIN\-CONNECTOR\)
  * So if MAIN\-CONNECTOR didn’t create this chat then it panic

# Group connection

* Functionality:
* Add new user:
  * The from chat can add another user\, he must send symmetric key for chat encrypted by public key of adding user and the address of user itself
  * Chat in its turn send appropriate message to MAIN\-CONNECTOR
* Send message:
  * User from chat send message encrypted by symmetric key for that chat

![](img/Building%20a%20Secure%20and%20Decentralized%20Messaging%20App2.png)

# Messenger frontend

![](img/Building%20a%20Secure%20and%20Decentralized%20Messaging%20App3.png)

Functionality:

Send message to the chat

Add user to the chat

Create new chat

Show the content of the chat

Show user’s all chats

Register

Login

# Example of Secure chat creation

![](img/Building%20a%20Secure%20and%20Decentralized%20Messaging%20App4.png)

Known messenger for communication

![](img/Building%20a%20Secure%20and%20Decentralized%20Messaging%20App5.png)

Chat used for secure chat creation

![](img/Building%20a%20Secure%20and%20Decentralized%20Messaging%20App6.png)

# issue

Everyone can see with whom and how often you communicate \(but they don’t see the content\)

# Distributed messenger with secure chat participants

![](img/Building%20a%20Secure%20and%20Decentralized%20Messaging%20App7.png)

Everything that the user does\, he does exclusively in his contract

Every state that the user reads\, he reads exclusively from its own node

The main problem is how to establish secure connection

# Why user must write only in its own space

![](img/Building%20a%20Secure%20and%20Decentralized%20Messaging%20App8.png)

Since it's a blockchain\, everyone can see what you're doing and what contracts you're sending messages to\, so it's easy to find out chat participants\.

![](img/Building%20a%20Secure%20and%20Decentralized%20Messaging%20App9.png)

Every participants of the \(distributed\) chat writes messages in its own chat part and other users must know what contract state they must read to get your messages\.

So main problem is how to tell other participants about location of your chat part

# Example of such messenger

Main\-connector:Connections are established via it\, but it has no smart contract logic at all\, we can even consider it just as the storage for records

User’s frontend:Keep order of distributed chats and handles all connection logic

![](img/Building%20a%20Secure%20and%20Decentralized%20Messaging%20App10.png)

# User A establishes connection with User B

1\. User A creates his part of the chat\, part A for example\. Also he generates symmetric key for this chat part

2\. User A write an invitation record in the MAIN\-CONNECTOR

3\. User B scans all records from MAIN\-CONNECTOR and decrypts them by his private key if he got his address then he knows that this was made on purpose and now he knows that User A wants to chat with him and here is his chat part and symmetric key

4\. User B write response on User A invitation as a record in MAIN\-CONNECTOR

![](img/Building%20a%20Secure%20and%20Decentralized%20Messaging%20App11.png)

![](img/Building%20a%20Secure%20and%20Decentralized%20Messaging%20App12.png)

# User a establishes connection with users 1 … n

2\. For all users 1 … N\, user A write an invitation in MAIN\-CONNECTOR

1\. User A creates chat and write in it all data about participants

3\. User i creates its own chat part and write response about it in MAIN\-CONNECTOR

4\. User i \(and User A\) listen all coming records in MAIN\-CONNECTOR from other users and decrypt it by symmetric key\, if it has response from some user then now it knows his chat part and can stop listening this user records

![](img/Building%20a%20Secure%20and%20Decentralized%20Messaging%20App13.png)

![](img/Building%20a%20Secure%20and%20Decentralized%20Messaging%20App14.png)

![](img/Building%20a%20Secure%20and%20Decentralized%20Messaging%20App15.png)

