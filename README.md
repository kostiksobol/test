<a name="br1"></a> 



<a name="br2"></a> 

Benefits of distributed Messaging Dapp **:**

• Enhanced Security: Actor-based communication

minimizes attack vectors, reducing potential

vulnerabilities

• Scalability: Actor-based architecture enables efficient

parallel processing of transactions, improving

performance

• Privacy: Messages are end-to-end encrypted, ensuring

confidentiality and protecting user data

• Decentralization: The absence of a central authority

empowers users and promotes censorship resistance

• User Control: Users have ownership of their data and

cryptographic identities, promoting data sovereignty



<a name="br3"></a> 

Functionality:

• Register user public key:

User just sends his public key

• Create new group chat:

User send generated by him encrypted symmetric key for future

created chat

• Create new pair chat:

User send symmetric key encrypted by his public key and by public

key of user with which he wants to start communication and address

of that user

• Add user in the chat:

Can only be sent by chats themselves (so, if user want to add

another user in the chat he must send it to the chat, and chat in its

turn send it to MAIN-CONNECTOR)

So if MAIN-CONNECTOR didn’t create this chat then it panic



<a name="br4"></a> 

Functionality:

• Add new user:

The from chat can add another user, he must send

symmetric key for chat encrypted by public key of

adding user and the address of user itself

Chat in its turn send appropriate message to MAIN-

CONNECTOR

• Send message:

User from chat send message encrypted by

symmetric key for that chat



<a name="br5"></a> 

Functionality:

• Send message to the chat

• Add user to the chat

• Create new chat

• Show the content of the chat

• Show user’s all chats

• Register

• Login



<a name="br6"></a> 

Known messenger for

communication

Chat used for secure

chat creation

Secure chat



<a name="br7"></a> 

• Everyone can see with whom and how often you communicate (but they don’t see

the content)



<a name="br8"></a> 

• Everything that the user does, he does

exclusively in his contract

• Every state that the user reads, he reads

exclusively from its own node

The main problem is how to establish secure

connection



<a name="br9"></a> 

Since it's a blockchain, everyone can

see what you're doing and what

contracts you're sending messages

to, so it's easy to find out chat

participants.

Every participants of the (distributed)

chat writes messages in its own chat part

and other users must know what contract

state they must read to get your

messages.

So main problem is how to tell other

participants about location of your chat

part



<a name="br10"></a> 

• Main-connector:

Connections are established via it, but it has

no smart contract logic at all, we can even

consider it just as the storage for records

• User’s frontend:

Keep order of distributed chats and handles

all connection logic



<a name="br11"></a> 

1\. User A creates his 2. User A write an invitation

3\. User B scans all

records from MAIN-

CONNECTOR and

4\. User B write response on

User A invitation as a record in

MAIN-CONNECTOR

part of the chat, part

A for example. Also

he generates

record in the MAIN-

CONNECTOR

decrypts them by his

private key if he got his

address then he knows

that this was made on

purpose and now he

knows that User A wants

to chat with him and here

is his chat part and

symmetric key

symmetric key for

this chat part



<a name="br12"></a> 

2\. For all users 1 … N,

user A write an invitation

in MAIN-CONNECTOR

1\. User A creates chat

and write in it all data

about participants

3\. User i creates its own chat 4. User i (and User A) listen all

part and write response

about it in MAIN-

CONNECTOR

coming records in MAIN-

CONNECTOR from other

users and decrypt it by

symmetric key, if it has

response from some user

then now it knows his chat

part and can stop listening this

user records

